##
# @file analyzer.py
# @author Roman Moroz
# @brief Сервисный модуль, отвечающий за взаимодействие с ИИ-моделями.
# @details Этот модуль содержит класс `CallAnalyzer`, который является "мозгом" бота.
#          Он инкапсулирует всю логику, связанную с API-запросами к ИИ, обработкой
#          текста и формированием ответа. Ключевая особенность - использование
# 

import logging

from openai import AsyncOpenAI
from config.config import settings

logger = logging.getLogger("call_assessment_bot")

class CallAnalyzer:
    """!
    @class CallAnalyzer
    @brief Инкапсулирует всю логику для анализа расшифровок звонков с помощью ИИ.
    @details
    Этот класс предоставляет единый метод `analyze_call` для выполнения всей работы.
    В конструкторе он настраивает асинхронный клиент для взаимодействия с API,
    а сам метод отвечает за формирование промпта, вызов модели и обработку ее ответа,
    включая возможные ошибки.
    """
    
    def __init__(self):
        """!
        @brief Конструктор класса `CallAnalyzer`.
        @details
        Инициализирует асинхронный клиент `AsyncOpenAI`, но настраивает его для работы
        с серверами OpenRouter. Это ключевое решение, позволяющее:
        1.  Обойти гео-блокировки, с которыми можно столкнуться при прямом использовании OpenAI.
        2.  Получить доступ к широкому спектру моделей от разных провайдеров (Google, Anthropic и др.).
        
        Клиент создается один раз при старте приложения, что обеспечивает эффективность.
        
        """
        
        self.client = AsyncOpenAI(
            base_url="https://openrouter.ai/api/v1",
            api_key=settings.OPENROUTER_API_KEY.get_secret_value(),
            default_headers={
                "HTTP-Referer": "https://github.com/crissyro/Call-rating-AI-bot", 
                "X-Title": "Call rating AI bot",
            },
        )
        logger.info("Async client for OpenRouter initialized successfully.")

    async def analyze_call(self, transcript: str) -> str:
        """!
        @brief Анализирует расшифровку звонка и возвращает отформатированный результат.
        @details
        Это основной рабочий метод класса. Он выполняет следующие шаги:
        1.  Формирует детальный системный промпт (`system_prompt`), который инструктирует
            модель выдать ответ в строго заданном формате Markdown. Это критически
            важно для получения предсказуемого и структурированного результата.
        2.  Выполняет асинхронный API-запрос к модели `google/gemini-flash-1.5`, которая
            является быстрым и мощным решением, доступным на OpenRouter.
        3.  Обрабатывает успешный ответ, извлекая из него текст.
        4.  Перехватывает любые исключения во время API-вызова (например, сетевые ошибки,
            проблемы с ключом), логирует их и возвращает пользователю вежливое
            сообщение об ошибке.
        
        @param transcript [in] Текст расшифровки телефонного разговора для анализа.
        @return Отформатированная строка с тональностью и рекомендациями, готовая
                к отправке пользователю, либо сообщение об ошибке.
        """
        
        system_prompt = (
            "Ты — опытный ИИ-аналитик колл-центра. Твоя задача — анализировать расшифровки "
            "телефонных разговоров. Внимательно изучи предоставленный диалог. "
            "Твой ответ должен быть четким, структурированным и на русском языке. "
            "Предоставь ответ СТРОГО в следующем формате Markdown, без лишних вступлений и заключений:\n\n"
            "**Тональность:** [здесь одно слово: Позитивная, Нейтральная или Негативная]\n\n"
            "**Рекомендации:**\n"
            "1. [здесь первая краткая и конкретная рекомендация по улучшению диалога]\n"
            "2. [здесь вторая краткая и конкретная рекомендация]"
        )
        
        try:
            response = await self.client.chat.completions.create(
                model="google/gemini-flash-1.5",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": transcript}
                ],
                temperature=0.4,
                max_tokens=500,
                timeout=40.0,
            )
            
            result_text = response.choices[0].message.content.strip()
            logger.info(f"Successfully received analysis from OpenRouter. Result length: {len(result_text)}")
            
            return result_text
        
        except Exception as e:
            logger.error(f"An error occurred during OpenRouter API call: {e}", exc_info=True)
            return ("⚠️ **Ошибка анализа**\n\n"
                    "Не удалось связаться с аналитическим сервисом. Пожалуйста, попробуйте снова.")

##
# @var analyzer
# @brief Единый экземпляр (синглтон) класса `CallAnalyzer`.
# @details Этот объект создается один раз при импорте модуля. Все остальные части
#          приложения (например, хендлеры в `analysis.py`) должны импортировать
#          и использовать этот готовый экземпляр. Это обеспечивает эффективность
#          (клиент API и его TCP-соединение создаются только один раз) и предоставляет
#          единую точку доступа к сервису анализа.
analyzer = CallAnalyzer()